# NEO节点的共识处理流程
---
## 基础知识
* NEO采用基于DBFT机制的共识算法，相关的技术文档可参考<http://docs.neo.org/zh-cn/basic/consensus/whitepaper.html>
    * 通过决议的最小节点数量：
    * `M = Validators.Length - (Validators.Length - 1) / 3;`
* 参与共识的节点：
  * NEO中默认参与共识的节点配置在protocol.json中的`StandbyValidators`里
  * 非共识节点，不会执行共识流程中的相关程序逻辑
  * ___其他非共识节点可以通过投票机制加入共识节点?___  

## 共识相关的类
  * `ConsensusService`类负责执行共识流程的程序逻辑
  * `ConsensusContext`类负责记录共识过程中的各种数据和状态

## 共识流程
  * 步骤1：
    * 开始新一轮共识
    * 初始化Context
    * 从共识节点中选出本轮的议长
    * 议长把本地节点记录的待出块交易记录到Context里
    * 记录待出块的交易数据时，会最前面插入一个新生成的MinerTransaction
    * 按照出块时间（15秒），开始倒计时
  * 步骤2：
    * 到达出块时间
    * 议长将新区块头签名，附带上记录在Context里的交易的Hash，用`PrepareRequest`消息广播出去      
    * 开始下一次倒计时(15秒)
  * 步骤3：
    * 议员收到`PrepareRequest`
    * 检查消息里的区块头的签名是否有效，通过后记录该签名
    * 根据消息体里的Hash，在本地节点查找并校验对应的交易数据，通过后并把这些交易数据记录到本地的Context里
    * 议员在完成上一步操作后，也生成一个新区块头的签名，用`PrepareResponse`消息广播出去 
  * 步骤4：
    * 每个共识节点收到区块头的签名后，会判断是否达到了通过决议的最小节点数，
    * 如果通过了，会用Context里的记录的交易生成新的区块
    * 广播新生成的区块，等待把新区块保存到本地的数据库中
    * 新区块保存完毕，本轮共识结束，开始新一轮的共识
  * 超时处理：
    * 如果超过了出块时间（15秒）还没有完成共识，则认为本次共识失败
    * 超时节点会广播希望变更视图的消息，并附带上希望变更后的新编号
    * 其他共识节点收到希望变更视图的消息后，会记录该编号，并判断同意变更到该编号的节点数量是否达到了通过决议的最小节点数
    * 达到了则变更视图，重新开始本轮的共识

## 共识流程里用到的网络消息
  * `PrepareRequest`
    * 开始共识时由议长广播
    * 消息体里包括新区块头的签名和所有待共识交易的Hash
  * `PrepareResponse`
    * 议员收到`RepareRequest`，成功校验需要共识的签名和交易数据后广播
    * 消息体里有议员签名的新区块头
  * `ChangeView`
    * 共识节点希望变更视图时发送
    * 消息体里有期望的新视图编号

## 变更视图
  * 目前有三种情况下会要变更视图
    * 议员收到议长发来的交易数据不合法，或者交易的Hash已经被使用过
    * 议员收到议长发来的区块头里的记账人合约地址和本地生成的不一致
    * 本次共识超时，议员和议长都会发起变更视图
  * 变更视图的流程
    * 变更视图也有一个类似的共识流程
    * 首先由希望变更视图的节点发广播，并附带上变更后的视图编号（由当前区块高度和视图编号决定）
    * 节点收到变更视图的消息后，判断该编号是否达到了通过决议的最小数量，达到了则进行视图变更
  * 完善建议
    * 目前共识过程中，会记录日志来方便追查问题，建议把在发起变更视图时，把原因也加到日志里

## 疑问
  * 每次开始新一轮共识时，会从mem_pool里的所有交易数据记录到Context里，作为本次待共识的交易，并等待15秒后发送
    * 在等待的15秒里收到新的交易请求不会被放在本轮共识里处理，要等下一轮共识？
    * 每一轮共识处理的交易数量没有上限，会把mem_pool里所有的交易都作为待共识的交易？